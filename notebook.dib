#!meta

{"kernelInfo":{"defaultKernelName":null,"items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"html","languageName":"HTML"},{"name":"sql","languageName":"SQL"},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"httpRequest","languageName":"http"},{"name":"value"}]}}

#!markdown

# Learning some c# stuff

#!markdown

## Structs

#!csharp

struct Location
{
    public int x, y;

    public Location(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

#!markdown

This is a struct, it's a value type, so it's stored on the stack. It's a bit like a class, but it's a bit more lightweight. Its properties are copied when you pass it around, so it's a bit like a primitive type.

#!csharp

Location l = new Location(20, 20);
Location la = l;
Console.WriteLine(la.y);
l.y = 9;
Console.WriteLine(la.y);
Console.WriteLine(l.y);
(double, double) t = (1.0, 2.0);
Console.WriteLine(t.Item1);

#!markdown

Above the l value is assigned to the la value, so the l value is a copy of the la value but not a reference to it. So if you change the l value, it doesn't change the la value.

#!markdown

## Tuple
The tuples feature provides concise syntax to group multiple data elements in a lightweight data structure. You cannot define methods in a tuple type, but you can define methods that operate on tuples.
For example:

#!csharp

(double, int) myTuple = (4.5, 3);
Console.WriteLine(myTuple.Item1);
Console.WriteLine(myTuple.Item2);

// Tuple with named elements
(double v1, int v2) myTuple3 = (v1: 1.1, v2: 2);
Console.WriteLine(myTuple3.v1);

#!markdown

## The delegate type
A delegate is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance. Delegates are used to pass methods as arguments to other methods. The .NET Framework class library contains many predefined delegates, such as the EventHandler delegate (used to handle events) and the Predicate delegate (used with the Array.Find method). This will be useful more with events.

#!csharp

public delegate int PerformCalculation(int x, int y);

#!markdown

Any method that matches the signature of the delegate can be assigned to the delegate.

#!csharp

// Create a method for a delegate.
public static int DelegateMethod(int a, int b)
{
    return a + b;
}

// Instantiate the delegate.
PerformCalculation calc = DelegateMethod;

// Call the delegate.
Console.WriteLine(calc(3, 4));

// Passing a delegate as a parameter.
public static void MethodWithCallback(int param1, int param2, PerformCalculation callback)
{
    int value = callback(param1 , param2);
    Console.WriteLine(value);
}
